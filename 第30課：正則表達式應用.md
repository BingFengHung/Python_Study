# 第 30 課：正則表達式應用 

## 正則表達式相關知識
在撰寫處理字串的程式時，經常會遇到在一段字串中查找符合某些規則字串的需求 (身分證字號匹配、電話號碼是否符合規則、信箱是否符合格式等等)，正則表達式就是用來描述這些規則的工具。

我們可以使用正則表達式來定義字串的匹配模式，即如何檢查一個字串是否有跟某種模式相匹配的部分或是從一個字串中將有與模式匹配的部分取出來或是替換。

舉一個簡單的例子，在 Windows 作業系統中使用檔案搜尋功能，並在指定檔案名稱時，使用過萬用字元 (`*` 和 `?`)，那麼正則表達式也是與之類似用來進行字串匹配的工具，只不過比起萬用字元正則表達式更加強大，他能精準描述需求，不過撰寫起來會比較複雜。


:fire:Python 透過函式庫中的 re 模組來支提供ㄌ表達式的操作。

> 以下是 metacharacters 的完整列表  
> `.` `^` `$` `*` `+` `?` `{` `}` `[` `]` `\` `|` `(` `)` 

|符號|說明|範例|說明|
|----|----|---|----|
|.|匹配任意字元|b.t|可以匹配 bat / but / b#t / b1t 等|
|\w|匹配英文字母/ 數字 / 下底線| b\wt| 可以匹配 bat / b1t / b_t 等 但不可匹配 b#t|
|\s|匹配空白字元 (包含 \r、\n、\t 等)|love\syou| 可以匹配 `love you`|
|\d|匹配數字|\d\d|可以匹配 01 / 24 / 99 等 |
|\b|匹配英文字母/數字/下底線的邊界 <br> 表示字元的"前面" 或"後面"除了空白、標點符號或是在字串開頭或結尾之外不可再有其他字元| \bThe\b |匹配 The Apple，不匹配 TheApple|
|^|匹配字串的開始|^The|匹配 The 開頭的字串|
|$|匹配字串的結束|.exe$|匹配 .exe 結尾的字串|
|\W|匹配非英文字母 / 數字 / 下底線|b\Wt| 可以匹配 b#t / b@t 等 <br> 不可匹配 but / b1t / b_t 等|
|\S|匹配非空白|love\Syou| 可以匹配 love#you 等 <br> 不可匹配 love you|
|\D|匹配非數字|\d\D|可以匹配 9a / 3# / 0F 等
|\B|匹配非單字邊界| \Bio\B||
|[]|匹配來自字元集合的任意單一字元|[aeiou]|可以匹配單一母音字母|
|[^]|匹配不再字元集合裡面的任何單一字元|[^aeiou]|可以匹配任何非單一母音字母|
|\*|匹配 0 次或多次|\w*|匹配 ` ` `a` `b` `b_a` `a1b`|
|+|匹配 1 次或多次|\w+|匹配 `a` `b` `a_b` `a1b`|
|?|匹配 0 次或 1 次|\w?|匹配 ` ` `a`|
|{N}|匹配 N 次|\w{3}| |
|{M,}|匹配至少 M 次| \w{3,}| |
|{M,N}|匹配至少 M 次到最多 N 次|\w{3,6}|
|\||分支|foo|bar|可以匹配 foo 或是 bar|
(?#)|註解|||
(exp)|匹配 exp 並餔捉到自動命名的群組中|||
|(?\<name>exp)|匹配 exp 並捕捉到名為 name 的群組中|||
| (?:exp)            | 匹配 exp 但是不捕捉匹配的字串              |                  |                                                    |
| (?=exp)            | 匹配 exp 前面的位置                         | \\b\\w+(?=ing)     | 可以匹配 I'm dancing 中的danc                        |
| (?<=exp)           | 匹配 exp 後面的位置                         | (?<=\\bdanc)\\w+\\b | 可以匹配I love dancing and reading中的第一个ing    |
| (?!exp)            | 匹配後面不是exp的位置                     |                  |                                                    |
| (?<!exp)           | 匹配前面不是exp的位置                     |                  |                                                    |
| *?                 | 重複任意次數，但盡可能少重複 | a.\*b<br>a.\*?b | 將正則表達式應用於aabab，前者會匹配整個字串 aabab，後者會匹配 aab 和 ab 兩個字串 |
| +?                 | 重複 1次或多次，但盡可能少重複 |                  |                                                    |
| ??                 | 重複 0次或1次，但盡可能少重複 |                  |                                                    |
| {M,N}?             | 重複 M到N次，但盡可能少重複 |                  |                                                    |
| {M,}?              | 重複 M次以上，但盡可能少重複 |                  |                                                    |

> 如果需要匹配的字串是正則表達式中的特殊字元，那麼可以使用 `\` 進行轉義處理，例如想要匹配小數點可以寫成 `\.`，因為直接寫 `.` 會匹配任意字元。

## Python 對正則表達式的支援

下面是 Python `re` 模組的核心函數

| -------------------------------------------- | ------------------------------------------------------------ |
| compile(pattern, flags=0)                    | 編譯正則表達式，回傳正則表達式的物件                            |
| match(pattern, string, flags=0)              | 用正則表達式匹配字串，成功會回傳物件，失敗回傳 None              |
| search(pattern, string, flags=0)             | 搜尋字串中第一次出现正則表達式的模式 成功會回傳匹配物件 否則回傳 None |
| split(pattern, string, maxsplit=0, flags=0)  | 用正則表達式指定的模式分割字串並返回串列                |
| sub(pattern, repl, string, count=0, flags=0) | 用指定的字符串替换原字符串中与正則表達式匹配的模式 可以用count指定替換的次數 |
| fullmatch(pattern, string, flags=0)          | match 函式的完全匹配 (從字串開頭到結尾）版本                |
| findall(pattern, string, flags=0)            | 查詢字串所有與正則表達式匹配的模式 回傳字串的串列       |
| finditer(pattern, string, flags=0)           | 查詢字串所有與正則表達式匹配的模式 回傳一個迭代器           |
| purge()                                      | 清除隱含編譯的正則表達式的緩存                               |
| re.I / re.IGNORECASE                         | 忽略大小寫匹配標記                                           |
| re.M / re.MULTILINE                          | 多行匹配標記                                                 |

> 上面提到的 `re` 模組中的這些函數，實際開發中也可以用正則表達式物件 (`Pattern` 物件) 的方法替代對這些函數的使用，如果一個正則表達式需要重複的使用，那麼先透過 `compile` 函數編譯正則表達式並建立出正則表達式物件是更明智的選擇

下面範例介紹如何使用正則表達式

#### 範例 1：驗證使用者名稱與密碼是否有錯誤並顯示對應的訊息

```py
"""
需求：使用者名稱必須是由字母、數字或下底線構成並且長度在 6~20 個字元之間，密碼是 6~12 個數字且第一個字不可為 0
"""
import re

username = input('請輸入使用者名稱: ')
password = input('請輸入密碼')
# match 函數的第一個參數是正則表達式字串或正則表達式物件
# match 函數的第二個參數是要跟正則表達式做匹配的字串
m1 = re.match(r'^[0-9a-zA-Z_]{6,20}$', username)

if not m1:
    print('請輸入正確的使用者名稱.')

# fullmatch 函數要求字串和正則表達式完全匹配
# 所以正則表達式沒有寫起始符號與結束符號
m2 = re.fullmatch(r'[1-9]\d{5,11}', password)
if not m2:
    print('密碼格式錯誤.')
if m1 and m2:
    print('申請成功!')
```

> 上面再撰寫正則表達式時，使用了 "原始字串" 的寫法 (在字串前面加上 `r`)，所謂"原始字串"就是字串中的每個字串都是它原始的意義，說得更直接一點，就是字串沒有所謂的轉義字串。因為正則表達式中有很多元字元和需要轉義的地方，如果不能使用原始字串就需要將反斜線寫成 `\\`，例如表示數字的 `\d` 必須寫成 `\\d`，這樣不僅寫起來不方便也不好閱讀。

## 範例 2：從一段文字中取得手機號碼。

```py
import re

# 建立正則表達式物件，使用前瞻和回顧來確保手機號碼前後不應該再出現數字
pattern = re.compile(r'(?<=\D)09\d{8}(?=\D)')
sentence = '''重要的事情說8130123456789遍，我的手機號碼是0912345678這個號碼，
不是0987654321，也不是110或119，小名的手機號碼才是0987654321。'''

# 方法一：查找所有匹配並表存到一個串列中
tels_list = re.findall(pattern, sentence)
for tel in tels_list:
    print(tel)
print('-----------------------------')

# 方法二：透過迭代器取出匹配物件並取得匹配內容
for temp in pattern.finditer(sentence):
    print(temp.group())
print('-----------------------------')

# 方法三：透過 search 函數指定搜尋位置找出所有匹配
m = pattern.search(sentence)

while m:
    print(m.group())
    m = pattern.search(sentence, m.end())
```

## 範例 3：替換字串中的不良內容

```Python
import re

sentence = 'Oh, shit! 你是笨蛋嗎? Fuck you.'
purified = re.sub('fuck|shit|[笨蛋]',
                  '*', sentence, flags=re.IGNORECASE)
print(purified)  # Oh, *! 你是*吗? * you.
```

> `re` 模組的正則表達式相關函釋中都有一個 `flags` 參數，他代表了正則表達式的匹配標記，可以透過該標記來指定匹配時是否忽略大小寫、是否進行多行匹配、是否顯示測試訊息等。如果需要為 flags 參數指定多個值，可以使用或運算子進行疊加，例如，`flags=re.I | re.M`

## 範例 4：拆分字串

```Python
import re

poem = '床前明月光，疑是地上霜。舉頭望明月，低頭思故鄉。'
sentences_list = re.split(r'[，。]', poem)
sentences_list = [sentence for sentence in sentences_list if sentence]
for sentence in sentences_list:
    print(sentence)
```
