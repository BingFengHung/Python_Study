# 第 17 課：物件導向程式設計入門

物件導向程式設計是一種非常流行的`編程範式 (程式設計法)`，所謂的編程範式就是`程式設計的方法論`，簡單的說就是程式開發人員對於程式的認知和理解以及他們的程式撰寫的方式。

> wiki: 程式設計法提供並決定了程式設計師對程式執行的看法。
> 例如，在物件導向程式設計中，程式設計師認為程式是一系列`相互作用的物件`，由於方法論的不同，物件導向程式設計範型又分為類別為基程式設計和基於原型程式設計，而在函式語言程式設計中一個程式會被看作是一個無狀態的函式計算的序列。

前面說過`程式是指令的集合`，執行程式時，程式中的語句會變成多條指令，然後由 CPU (中央處理器) 去執行。
前面也講到函數，`把相對獨立且經常重複使用的程式碼放到函數中`，在需要使用這些程式碼的時候呼叫函數即可。

電腦的工作方式與人類思維模式是不同的，如果當我們按照電腦的工作方式去撰寫程式，當我們需要開發一個複雜的系統時，這種方式會讓程式碼過於複雜，導致開發和維護工作變得困難。 (我們根據電腦的規則去寫程式，程式完成了，達到任務目的，但是後續要增加新功能或是修改，可能就少了彈性)

隨著軟體複雜度的增加，`撰寫正確可靠的程式碼變成一項艱難的任務`，這也是很多人都相信"軟體開發是人類改造世界所有活動中最複雜的活動"原因。如何用程式描述複雜系統和解決複雜的問題，成為了所有開發人員必須思考的問題。

上世紀 70 年代的 Smalltalk 語言，讓軟體開發人員看到了希望，因為它引入了物件導向程式設計的概念。
在物件導向的世界中，程式中的`資料和操作資料的函數是一個邏輯上的整體`，稱之為物件，`物件可以接收訊息`，解決問題的方法就是`建立物件並對物件發出各式各樣的訊息`；透過訊息傳送，程式中的多個物件可以共同工作，這樣就能建構出複雜的系統並解決現實世界的問題。

> 說明：現今，很多程式語言都支援物件導向程式設計，但是物件導向程式設計也不是解決軟體開發中所有問題的"銀彈"，或是說在軟體開發這個行業還沒找到這種所謂的"銀彈"。

## 類別和物件
> `物件導向程式設計`：將一組資料和處理資料的方法組成`物件`，將行為相同的物件歸類為`類別`，透過`封裝`隱藏物件的內部細節，透過`繼承`實現類別的特化和泛化，透過`多型`實現基於物件類型的動態分派。

- 封裝 (Encapsulation)
- 繼承 (Inheritance)
- 多型 (Polymorphism)

在物件導向程式設計中，`類別是一個抽象的概念，物件是一個具體的概念`，將同一類物件的共同特徵抽取出來就是一個類別，例如人類，是一個抽象概念，而我們每個人就是人類這個抽象概念下的存在，也就是物件。簡言之，**類別是物件的藍圖和模板，物件是類別的實例，是可以接收消息的實體**

在物件導向的世界中，`一切皆為物件`，`物件都有屬性和行為`,`每個物件都是獨一無二的`，並且`物件一定屬於某個類別`。物件的屬性是物件的靜態特徵，物件的行為是物件的動態特徵，按照上面的說法，如果我們將有共同特徵的物件的屬性和行為都抽取出來，就可以定義成一個類別了。

<img src="https://gitee.com/jackfrued/mypic/raw/master/20210731182741.png" width="75%">

## 類別定義
在 Python 中，可以使用 `class` 關鍵字加上類別名稱來定義類別，在類別的程式碼中，我們需要寫一些函數，有說過類別是一個抽象概念，那麼這些函數就是我們對一個類別物件共同的動態特徵的提取，寫在類別裡面的函數稱之為`方法`，方法就是物件的行為，也就是物件可以接收的消息。

方法第一個參數通常是 `self`，代表接收這個消息的物件本身。

```py
class Student:
    def study(self, course_name):
        print(f'學生正在學習{course_name}.')

    def play(self):
        print(f'學生正在玩遊戲.')
```
## 建立和使用物件
定義好類別之後，可以使用建構子語法來建立物件，程式碼如下所示：

```py
stu1 = Student()
stu2 = Student()
print(stu1)    # <__main__.Student object at 0x10ad5ac50>
print(stu2)    # <__main__.Student object at 0x10ad5acd0> 
print(hex(id(stu1)), hex(id(stu2)))    # 0x10ad5ac50 0x10ad5acd0
```

上面的程式碼可以看到印出來的物件在記憶體中的位置 (16 進制形式)，跟使用 `id` 函數查看物件標示獲得的值是一樣的。

我們定義的變數保存的是一個物件在記憶體中的邏輯位址，透過這個邏輯位址，就可以在記憶體中找到這個物件，因此，`stu3 = stu2` 這樣的賦值語法並沒有建立新的物件，只是用一個新的變數保存了已有物件的位址。

接下來，嘗試給物件發送消息，就是呼叫物件方法。在 Python 中，給物件發送訊息有兩種方式，如下所示：

```py
# 透過 "類別.方法" 呼叫方法，第一個參數是接收訊息的物件，第二個參數是學習的課程名稱
Student.study(stu1, 'Python 程式開發')    # 學生在在學習 Python 程式開發 

# 透過 "物件.方法" 呼叫方法，點前面的物件就是接收訊息的物件，只需要傳入第二個參數
stu1.study('Python 程式開發')  # 學生在在學習 Python 程式開發 

Student.play(stu2)    # 學生正在玩遊戲.
stu2.play()           # 學生正在玩遊戲. 
```

### 初始化方法
剛剛建立的物件只有行為沒有屬性，如果要給物件定義屬性，修改剛剛的 `Student` 類別，並在裡面加入一個 `__init__` 方法 (建構子)。

在呼叫 `Student` 類別的建構子建立物件時，首先會在記憶體中獲得儲存學生物件所需的記憶體空間，然後會自動執行 `__init__` 方法，完成對記憶體的初始化操作，友就是將資料存到記憶體中，所以透過 `Student` 類別加入 `__init__` 方法的方式，為物件指定屬性，同時完成對屬性設定初始值的動作，因此，`__init__` 方法通常也稱作初始化方法。

程式碼如下所示：

```py
class Student:
    def __init__(self, name, age):
        """初始化方法"""
        self.name = name
        self.age = age

    def study(self, course_name):
        print(f'{self.name}正在學習{course_name}.')

    def play(self):
        print(f'{self.name}正在玩遊戲.')
```

```py
# 由於初始化方法除了 self 之外還有兩個參數
# 所以呼叫 Student 類別的建構子建立物件時，要傳入兩個參數
stu1 = Student('Joe', 18)
stu2 = Student('Tim', 15)
stu1.study('Python 程式設計')    # Joe正在學習 Python 程式設計.
stu2.play()                    # Tim 正在玩遊戲.
```

### 列印物件
在 Python 中，兩個下底線 `__` (讀作 'dunder') 開頭和結尾的方法通常是有特殊用途與意義的，一般稱為**魔術方法**。

如果我們在印出物件的時候，不希望看到物件的位址，而是我們自定義的訊息，可以透過在類別中放置 `__repr__` 魔術方法來做到，該方法返回的字串，就是用 `print` 函數列印物件時候會顯示的內容，如下程式碼所示：

```py
class Student:
    def __init__(self, name, age):
        """初始化方法"""
        self.name = name
        self.age = age

    def study(self, course_name):
        print(f'{self.name}正在學習{course_name}.')

    def play(self):
        print(f'{self.name}正在玩遊戲.')
    
    def __repr__(self):
        return f'{self.name}: {self.age}'


stu1 = Student('Joe', 18)
print(stu1)        # Joe: 18
students = [stu1, Student('Tim', 36), Student('Jerry', 25)]
print(students)    # [Joe: 40, Tim: 36, Jerry: 25]
```

## 物件導向的支柱
物件導向有三大支柱：`封裝`、`繼承`、`多型`

封裝：隱藏一切可以隱藏的實作細節，只向外面公開簡單的呼叫介面。

在類別中定義的物件方法就是一種封裝，這種封裝可以讓我們在建立物件之後，只需要給物件發送一個訊息，就可以執行方法中的程式碼，也就是說只知道方法的名字和參數，不知道方法內部實作細節的情況下，就完成了方法的使用。

> ex，叫一個機器人倒水，如果不使用物件導向開發，不做任何的封裝，就需要像這個機器人發出一系列的指令，如站立、向左轉、向前5步...等，才能完成簡單的操作，如果按照物件導向的思維，就可以將倒水的指令封裝到機器人的一個方法中，當需要機器人倒水時，只要向機器人發出倒水的訊息就可以了。

在很多情境，物件導向其實就是三步驟的問題，第一步定義類別，第二步建立物件，第三步給物件發送訊息。

當然有時，我們不需要第一步驟，因為享用的類別已經存在，例如，Python 內建的 `list`、`set`、`dict` 其實都不是函數而是類別，因為是內建的，不用再自行定義類別。有些類別不是 Python 標準函式庫直接提供的，來自第三方程式碼，如何使用後面會說明。

在某些特殊情境中，會用名為 `內建物件` 的物件，所謂內建物件就是上面三步驟的第一、二都不需要，因為類別已經存在並建立過了，直接向物件發送訊息即可，也就是常說的 `開箱即用`。 (在 C# 中像是已經可以直接呼叫的 Date 類別等類別，不用 new 就可以直接使用)

## 案例說明
#### 案例 1：定義一個描述數字時鐘的類別。

```py
import time

# 定義數字時鐘
class Clock(object):
    """數字時鐘"""

    def __init__(self, hour=0, minute=0, second=0):
        """初始化方法
        :param hour: 時
        :param minute: 分
        :param second: 秒
        """
        self.hour = hour
        self.min = minute
        self.sec = second

    def run(self):
        """時間走動"""
        self.sec += 1
        if self.sec == 60:
            self.sec = 0
            self.min += 1
            if self.min == 60:
                self.min = 0
                self.hour += 1
                if self.hour == 24:
                    self.hour = 0

    def show(self):
        """顯示時間"""
        return f'{self.hour:0>2d}:{self.min:0>2d}:{self.sec:0>2d}'


# 建立時鐘物件
clock = Clock(23, 59, 58)

while True:
    # 給時鐘物件發送讀取時間的訊息
    print(clock.show())
    # 暫停 1 秒鐘
    time.sleep(1)
    # 給時鐘物件發送時間走動訊息
    clock.run()
```

### 案例 2：定義一個描述平面上的點，要求提供計算到另一點距離方法的類別
```py
class Point(object):
    def __init__(self, x=0, y=0):
        """
        :param x: 横坐标
        :param y: 纵坐标
        """
        self.x, self.y = x, y

    def distance_to(self, other):
        """計算點到點的距離
        :param other: 另一個點
        """
        dx = self.x - other.x
        dy = self.y - other.y
        return (dx * dx + dy * dy) ** 0.5

    def __str__(self):
        return f'({self.x}, {self.y})'


p1 = Point(3, 5)
p2 = Point(6, 9)
print(p1, p2)
print(p1.distance_to(p2))
```

## 總結
除了物件導向之外，還有`指令程式開發`、`函數式程式開發`等編程範式。

在物件導向的世界中，由於是由物件的構成，物件是可以接受訊息的實體，所以`物件導向開發更符合人類正常的思考習慣`。

類別是抽象的，物件是具體的，有了類別就能建立物件，有了物件就可以接收訊息，這就是物件導向的基礎。

定義類別的過程是抽象的過程，找到物件共用的屬性屬於資料抽象，找到物件共用的方法屬於行為抽象。

<img src="https://gitee.com/jackfrued/mypic/raw/master/20210731182914.png" width="75%">

## 補充
### __str__ 的功能與方法
1. `__str__` 功能，將物件按照自定義的格式用字串的形式顯示出來，增加可讀性
2. 物件在印出時預設呼叫 __str__ 方法，如果類別沒有重寫這個方法，育社會使用父類別 object 的 `__str__` 方法
3. object 的 `__str__` 方法內部是 pass，因此，印出來的會是記憶體位址。

### __repr__ 的功能與方法
1. __repr__ 如果用 IDE 軟體操作，功能與 `__str__` 完全一樣，都是實例可視化顯示
2. 開發中如果使用者需要可視化實例內容，只需要重寫 __str__ 或是 __repr__ 方法之一即可。如果兩個都有的畫，預設呼叫 __str__。
3. __str__ 與 __repr__ 區別在於指令的操作
  - __str__ 重寫後，如果直接在互動介面實例物件，顯示會是實例在記憶體中的位置，跟使用 print 物件是不一樣的。
  - __repr__ 重寫後，如果直接在互動介面寫實例物件，效果就跟使用 print 物件一樣，返回內容，不是記憶體位置
