# 第 18 課：物件導向程式開發進階
## 可见性和属性装饰器
## 存取可見性和屬性裝飾器
在很多物件導向程式語言中，物件的屬性通常會被設定為私有 (private) 或受保護 (protected) 的成員，簡單來說就是不允許直接存取這些屬性；物件的方法通常都是公開的 (public)，因為公開的方法是物件導向能夠接受的消息，也是物件導向公開給外界的呼叫介面，也就是所謂的存取可見性。

Python 中，透過給物件屬性名稱加入前綴下底線的方式來說明屬性的存取可見性，例如，`__name` 表是一個私有屬性，`_name` 表是一個受保護屬性，程式碼如下所示：

```py
class Student:
    def __init__(self, name, age):
        self.__name = name
        self.__age = age

    def study(self, course_name):
        print(f'{self.__name}正在學習{course_name}.')


stu = Student('Joe', 20)
stu.study('Python 程式開發')
print(stu.__name)
```
上面最後一行程式碼會導致 `AttributeError` (屬性錯誤) 異常，異常訊息為 `'Student' object has no attribute '__name'`。

由此可知，用 `__` 開頭的屬性 `__name` 是私有的，在類別外面無法存取，但是類別裡面的 `student` 方法可以透過 `self.__name` 存取該屬性。

:memo: Python 並沒有從語法上面嚴格保證私有屬性的私密性，它只是給私有屬性和方法換了一個名字來干擾對他們的存取，事實上，如果你知道更換名字的規則仍然可以存取到他們，如下範例，對上面的程式碼稍作修改就可以訪問到私有的屬性。

```py
class Student:
    def __init__(self, name, age):
        self.__name = name
        self.__age = age

    def study(self, course_name):
        print(f'{self.__name}正在學習{course_name}.')


stu = Student('Joe', 20)
stu.study('Python 程式開發')
print(stu._Student__name, stu._Student__age)
```

Python 語言的設計者認為開發人員要為自己的行為負責，不是由 Python 語言本身來嚴格限制存取可見性，大多數的發人員都認為 `開放比封閉好`，把物件的屬性私有化並不是程式開發必要的東西，所以 Python 並沒有從語法上面做出最嚴格的限制。

Python 中可以透過 `property` 裝飾器為"私有"屬性提供存取和修改的方法。
:fire: 裝飾器通常放在類別、函數或是方法的宣告之前。

```py
class Student:
    def __init__(self, name, age):
        self.__name = name
        self.__age = age

    # 屬性存取訪問器 (getter 方法) - 取得 __name 屬性
    @property
    def name(self):
        return self.__name
    
    # 屬性修改器 (setter 方法) - 修改 __name 屬性
    @name.setter
    def name(self, name):
        # 如果 name 參數不是空的，就賦值給物件的 __name 屬性
        # 否則將 __name 屬性賦值為 '無名氏'
        self.__name = name or '无名氏'
    
    @property
    def age(self):
        return self.__age


stu = Student('Joe', 20)
print(stu.name, stu.age)    # Joe 20
stu.name = ''
print(stu.name)    # 無名氏
# stu.age = 30     # AttributeError: can't set attribute
```

實際專案開發中，並不經常使用私有屬性，屬性裝飾器的使用也比較少，上面的知識簡單知道一下即可。

### 動態屬性
Python 是一門動態語言，wiki 說明是："在執行時，可以改變其結構的語言，例如新的函數、物件、甚至是程式碼都可以引入，已有的函數可以被刪除或是其他結構的變化。動態語言非常靈活，目前流行的 Python 和 JavaScript 都是動態語言，除此之外，如 PHP、Ruby 等也都屬於動態語言，而 C、C++ 等語言則不屬於動態語言"。
在 Python 中，可以動態幫物件加入屬性，這是 Python 作為動態語言的一項特權，程式碼如下所示。

***需要注意的是，物件的方法其實本質上也是物件的屬性**，如果給物件發送一個無法接收的消息，引發的異常仍然是 `AttributeError`。

```py
class Student:

    def __init__(self, name, age):
        self.name = name
        self.age = age


stu = Student('Joe', 20)

# 為 Student 物件動態加入 sex 屬性
stu.sex = '男'
```

如果不希望在使用物件時動態的幫物件加入屬性，可以使用 Python 的 `__slots__` 魔法，對於 `Student` 類別來說，可以在類別中指定 `__slots__ = ('name', 'age')`，這樣 `Student` 類別的物件只能有 `name` 和 `age` 屬性，如果想要動態加入其他屬性將會導致異常，程式碼如下所示：

```py
class Student:
    __slots__ = ('name', 'age')

    def __init__(self, name, age):
        self.name = name
        self.age = age


stu = Student('Joe', 20)
# AttributeError: 'Student' object has no attribute 'sex'
stu.sex = '男'
```

## 靜態方法和類別方法
前面在類別中定義的方法都是物件方法，換句話說這些方法都是物件可以接收的消息。除了物件方法之外，類別中還可以有靜態方法與類別方法，這兩類方法是發給類別的消息，兩者並沒有實質性的區別。

在物件導向的世界中，一切皆為物件，定義的每個類別其實也是一個物件，但是靜態方法與類別方法就是發送給類別物件的消息。

什麼樣的消息會直接發送給類別物件呢?

舉一個例子，定義一個三角形類別，透過傳入三條邊的長度來建構三角形，並提供計算周長與面積的方法，計算周長何面積肯定是三角形物件的方法。

但是在建立三角形物件時，傳入的三條邊長未必能夠建立出三角形，為此，可以先寫一個方法來驗證給定的三條邊長是否可以建構三角形，這種方法很明顯就不是物件方法，因為在呼叫這個方法時，三角形物件還沒有建立出來，可以將這類別的方法設計為靜態方法或是類別方法，也就是說這類別方法不是發送給三角形物件的訊息，而是發送給三井行類別的訊息，程式碼如下所示：

```py
class Triangle(object):
    """三角形類別"""

    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c

    @staticmethod
    def is_valid(a, b, c):
        """判斷三條邊長是否能建構三角形 (靜態方法)"""
        return a + b > c and b + c > a and a + c > b

    # @classmethod
    # def is_valid(cls, a, b, c):
    #     """判斷三條邊長是否能建構三角形 (靜態方法)"""
    #     return a + b > c and b + c > a and a + c > b

    def perimeter(self):
        """計算周長"""
        return self.a + self.b + self.c

    def area(self):
        """計算面積"""
        p = self.perimeter() / 2
        return (p * (p - self.a) * (p - self.b) * (p - self.c)) ** 0.5
```
